---
name: UseQuery Wrapper
menu: State Management
---

import { Playground, Props, Description} from 'documentation'
import { Editor } from 'documentation'

import { Protocol } from 'src/query/protocol';
import withQuery from 'src/query/withQuery';
import mockAPI from 'src/query/mockAPI';
import { useQuery } from 'src/query/useQuery';
import QueryProvider from 'src/query/QueryProvider';
import {
  List,
  ListItem,
  Typography
} from '@material-ui/core';

# UseQuery Wrapper
The following code snippet displays list of mount points from the mock response of storage profile api.
<Playground>
    {() => {
        // Mock response data
        const storageProfile = {
                clusterProfile: {
                    mounts: [
                    {
                        mountPoint: '/bb',
                        owner: 'root',
                        fsType: 'none',
                        size: 100,
                        volume: 'none',
                        mountType: 'Block',
                        os: 'linux',
                    },
                    {
                        mountPoint: 'OS',
                        owner: 'root',
                        fsType: 'none',
                        size: 100,
                        volume: 'none',
                        mountType: 'Block',
                        os: 'linux',
                    },
                    ],
                }
        };
        // Mock request / fetch call
        const queryStorageProfileNewMock  = async ({
            clusterName,
            useDefault: ignored,
            }) => new Promise((resolve) => resolve(storageProfile));
        
        const newMockAPI = {
            query: {
                ...mockAPI.query,
                // adding the function to the api
                storageProfile: queryStorageProfileNewMock
            },
            mutation: {
                ...mockAPI.mutation
            }
        }
        // withQuery wrapper set once for the api
        const {storageProfile:storageProfileQuery} = withQuery(newMockAPI.query);
        // A simple View 
        const Component = () => {
            const clusterName = 'ALETC';
            const { data: storageProfile = {} } = useQuery(
                storageProfileQuery,
                { clusterName },
            );
            const {clusterProfile: {mounts = []} = {}} = storageProfile
            return (
            <>
                <Typography>Mount Points</Typography>
                <List>
                    {mounts.map(mount => (
                        <ListItem>
                            {mount.mountPoint}
                        </ListItem>
                    ))}
                </List>
            </>
            )
        }
        // QueryProvider is set on the top level application component
        return (<QueryProvider><Component/></QueryProvider>)
    }}
</Playground>



## How does useQuery wrapper works?
```js
export default function withQuery<T extends Protocol['query']>(
  queries: T
): withQueryReturnType<T>
```
**withQuery** wrapper generates meta data needed for React Query from the list of api fetch functions in the Protocol interface.
Identifies the Parameter Type and Return type of each individual API functions


```js
export default function useQuery<
  P extends Protocol['query'],
  api extends keyof P,
  RespType extends ProtocolRespType<ReturnType<P[api]>>
>(
  queryDef: QueryDefinition<P, api>,
  reqBody: RequestParameters<P[api]>,
  config?: ReactQueryConfig<RespType>
): ReactQueryResult<RespType>
```
**useQuery**  wrapper generates react query Hooks based on the meta data generated by the withQuery wrapper.


## Entire useQuery standalone prototype
<Editor code={
    `
type Res3ReqBody = {
  a: number
  b: boolean
}
type Res3Response = {
  a: number
  b: boolean
}
interface Protocol {
    query: {
      [key:string]: (reqBody: any) => any
      resource1: () => void
      resource2: (reqBody: {a: number} ) => void
      resource3: (reqBody: Res3ReqBody) => Res3Response
    }
    mutation: {
      [key:string]: (reqBody: any) => any
      save: () => void
      remove: (reqBody: {a: number} ) => number
      update: (reqBody: Res3ReqBody) => string
    }
}
type RequestParameters<T extends (reqBody: any) => any> = T extends (reqBody: infer P) => any ? P : never
type QueryDefinition <P extends Protocol['query'], api extends keyof P> = {
    queryKey: keyof P
    queryFunction: (reqBody: RequestParameters<P[api]>)=> ReturnType<P[api]> 
}
// ---------------------
// withQuery.ts
type withQueryReturnType <T extends Protocol['query']> = {
    [api in keyof T]: QueryDefinition<T, api>
}
function withQuery <T extends Protocol['query']> (protocol: T): withQueryReturnType<T>{
    let query: withQueryReturnType<T>  = Object.assign({});
    for (let api in protocol) {
        let fn = protocol[api];
        let apiKey = api;
    
        query = Object.assign(query, {
            [apiKey]: {
                queryKey: apiKey,
                queryFunction: fn
            }
        });
    } 
    return query;
}
type ProtocolRespType<T> = T extends infer U ? U : never;
function useQuery <P extends Protocol['query'], api extends keyof P, RespType extends ProtocolRespType<ReturnType<P[api]>> > (
      queryDef: QueryDefinition<P, api>, 
      reqBody: RequestParameters<P[api]>,
      ): RespType 
{
    const ret: RespType = Object.assign({});
    return ret;
}
// ----------------------
// export query for service
// service.ts
let service : Protocol = {
  query: {
    resource1: () => {},
    resource2: ({ a } ) => { console.log ('service.fetch1', a) },
    resource3: ({ a, b}) => { console.log ('service.fetch2', a, b); return {a, b}},
  },
  mutation :{
    save: () => {},
    remove: ({a} ) => {return a},
    update: () => "",
  }
}
// -------------------------
// export these from service
const queries  = withQuery(service.query);
const { resource3, resource2 } = queries
// ---------------------------
// from component
const res3 = useQuery(resource3, {a: 1, b: true});`
} />
